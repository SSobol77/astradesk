// SPDX-License-Identifier: Apache-2.0
// File: Jenkinsfile v2 alfa --refactoring--
// Description:
//     Production Jenkins pipeline for AstraDesk.
//     Handles checkout, code analysis, testing (Python 3.14, Java 25, Node.js 22),
//     Docker build/push, Terraform infrastructure (VPC, EKS, RDS, S3),
//     configuration management (Ansible/Puppet/Salt), Istio mTLS (STRICT),
//     cert-manager HTTPS, Admin API secrets, and Helm deployment.
//     Integrates with infra/, ansible/, puppet/, salt/, deploy/istio/, deploy/chart/, and Admin API (/secrets).
// Author: Siergej Sobolewski
// Since: 2025-10-22

pipeline {
    agent none

    environment {
        REGISTRY_URL = "docker.io/youruser"  // Change to your Docker registry
        IMAGE_TAG = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
        KUBE_CREDENTIALS_ID = 'kubeconfig-astradesk'  // Kubernetes credentials ID
        AWS_CREDENTIALS_ID = 'aws-credentials'  // AWS credentials ID
        ADMIN_API_JWT = credentials('admin-api-jwt')  // Admin API JWT
        TERRAFORM_DIR = 'infra'
        TF_VAR_file = "${TERRAFORM_DIR}/terraform.tfvars"
        ANSIBLE_INVENTORY = 'ansible/inventories/dev/hosts.ini'
        PUPPET_MANIFEST = 'puppet/manifests/astradesk.pp'
        SALT_STATE = 'astradesk'
    }

    stages {
        stage('Checkout') {
            agent any
            steps {
                checkout scm
                stash name: 'source', includes: '**/*'
            }
        }

        stage('Code Analysis & Tests') {
            parallel {
                stage('Analyze & Test Python') {
                    agent { docker { image 'python:3.14-slim' } }
                    steps {
                        unstash 'source'
                        cache(path: '.venv', key: "venv-py-${checksum 'uv.lock'}") {
                            sh 'pip install --no-cache-dir uv'
                            sh 'uv sync --all-extras --frozen'
                        }
                        sh 'uv run ruff check .'
                        sh 'uv run mypy .'
                        sh 'uv run pytest --cov --cov-report=xml --junitxml=pytest-report.xml'
                        stash name: 'coverage-py', includes: 'coverage.xml,pytest-report.xml'
                    }
                }
                stage('Analyze & Test Java') {
                    agent { docker { image 'gradle:jdk25' } }
                    steps {
                        unstash 'source'
                        cache(path: '.gradle/caches', key: "gradle-caches-${checksum '**/*.gradle.kts'}") {
                            sh './gradlew check jacocoTestReport'
                        }
                        stash name: 'coverage-java', includes: '**/build/reports/jacoco/test/jacocoTestReport.xml'
                    }
                }
                stage('Analyze & Test Node.js') {
                    agent { docker { image 'node:22-alpine' } }
                    steps {
                        unstash 'source'
                        cache(path: 'services/admin-portal/node_modules', key: "npm-modules-${checksum 'services/admin-portal/package-lock.json'}") {
                            sh 'cd services/admin-portal && npm ci'
                        }
                        sh 'cd services/admin-portal && npm run lint && npm test -- --coverage'
                        stash name: 'coverage-node', includes: 'services/admin-portal/coverage/**'
                    }
                }
            }
        }

        stage('Store AWS Credentials') {
            agent { docker { image 'curlimages/curl' } }
            steps {
                unstash 'source'
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                    sh '''
                        curl -X POST http://localhost:8080/api/admin/v1/secrets -H "Authorization: Bearer ${ADMIN_API_JWT}" -d '{
                            "name": "aws_creds",
                            "type": "aws",
                            "access_key": "'${AWS_ACCESS_KEY_ID}'",
                            "secret_key": "'${AWS_SECRET_ACCESS_KEY}'"
                        }'
                    '''
                }
            }
        }

        stage('Terraform Init & Validate') {
            agent { docker { image 'hashicorp/terraform:1.7.0' } }
            steps {
                unstash 'source'
                dir(env.TERRAFORM_DIR) {
                    sh 'terraform init'
                    sh 'terraform validate'
                }
            }
        }

        stage('Terraform Plan') {
            agent { docker { image 'hashicorp/terraform:1.7.0' } }
            steps {
                unstash 'source'
                dir(env.TERRAFORM_DIR) {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID]]) {
                        sh 'terraform plan -var-file="${TF_VAR_file}" -out=plan.out'
                        stash name: 'terraform-plan', includes: 'infra/plan.out'
                    }
                }
            }
        }

        stage('Terraform Apply') {
            agent { docker { image 'hashicorp/terraform:1.7.0' } }
            when { branch 'main' }
            steps {
                unstash 'source'
                unstash 'terraform-plan'
                dir(env.TERRAFORM_DIR) {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID]]) {
                        sh 'terraform apply -auto-approve plan.out'
                    }
                }
            }
        }

        stage('Config Management Deployment') {
            parallel {
                stage('Test Config Management') {
                    steps {
                        unstash 'source'
                        script {
                            parallel(
                                'Ansible Test': {
                                    agent { docker { image 'python:3.14-slim' } }
                                    steps {
                                        sh 'pip install ansible'
                                        sh "ansible-playbook -i ${ANSIBLE_INVENTORY} ansible/playbook.yml --check > ansible-test.log 2>&1"
                                        stash name: 'ansible-test-log', includes: 'ansible-test.log'
                                    }
                                },
                                'Puppet Test': {
                                    agent { docker { image 'ubuntu:24.04' } }
                                    steps {
                                        sh 'apt-get update && apt-get install -y puppet-agent'
                                        sh "puppet apply ${PUPPET_MANIFEST} --noop > puppet-test.log 2>&1"
                                        stash name: 'puppet-test-log', includes: 'puppet-test.log'
                                    }
                                },
                                'Salt Test': {
                                    agent { docker { image 'ubuntu:24.04' } }
                                    steps {
                                        sh 'apt-get update && apt-get install -y salt-minion'
                                        sh "salt '*' state.apply ${SALT_STATE} test=True > salt-test.log 2>&1"
                                        stash name: 'salt-test-log', includes: 'salt-test.log'
                                    }
                                }
                            )
                        }
                    }
                }
                stage('Ansible Deploy') {
                    agent { docker { image 'python:3.14-slim' } }
                    steps {
                        unstash 'source'
                        sh 'pip install ansible'
                        sh "ansible-playbook -i ${ANSIBLE_INVENTORY} ansible/playbook.yml"
                    }
                }
                stage('Puppet Deploy') {
                    agent { docker { image 'ubuntu:24.04' } }
                    steps {
                        unstash 'source'
                        sh 'apt-get update && apt-get install -y puppet-agent'
                        sh "puppet apply ${PUPPET_MANIFEST}"
                    }
                }
                stage('Salt Deploy') {
                    agent { docker { image 'ubuntu:24.04' } }
                    steps {
                        unstash 'source'
                        sh 'apt-get update && apt-get install -y salt-minion'
                        sh "salt '*' state.apply ${SALT_STATE}"
                    }
                }
            }
        }

        stage('Build & Push Docker Images') {
            agent { docker { image 'docker:25' } }
            steps {
                unstash 'source'
                script {
                    withDockerRegistry(credentialsId: 'docker-credentials', url: 'https://index.docker.io/v1/') {
                        def images = [
                            "api": ".",
                            "ticket": "services/ticket-adapter-java",
                            "admin": "services/admin-portal",
                            "auditor": "services/auditor"
                        ]
                        images.each { name, path ->
                            def imageName = "${REGISTRY_URL}/astradesk-${name}:${IMAGE_TAG}"
                            sh "docker build --cache-from ${imageName} -t ${imageName} ${path}"
                            sh "docker push ${imageName}"
                        }
                    }
                }
            }
        }

        stage('Apply Istio Configs') {
            agent { docker { image 'bitnami/kubectl:latest' } }
            steps {
                unstash 'source'
                withCredentials([file(credentialsId: env.KUBE_CREDENTIALS_ID, variable: 'KUBECONFIG')]) {
                    retry(3) {
                        sh 'kubectl apply -f deploy/istio/ --kubeconfig=$KUBECONFIG'
                        sh 'istioctl analyze -n astradesk-prod --kubeconfig=$KUBECONFIG'
                    }
                }
            }
        }

        stage('Store Certificates in Admin API') {
            agent { docker { image 'bitnami/kubectl:latest' } }
            steps {
                unstash 'source'
                withCredentials([file(credentialsId: env.KUBE_CREDENTIALS_ID, variable: 'KUBECONFIG'), string(credentialsId: 'admin-api-jwt', variable: 'JWT')]) {
                    sh '''
                        kubectl get secret -n astradesk-prod astradesk-tls -o jsonpath='{.data.tls\\.crt}' --kubeconfig=$KUBECONFIG | base64 -d > mtls-cert.pem
                        curl -X POST http://localhost:8080/api/admin/v1/secrets -H "Authorization: Bearer $JWT" -d '{
                            "name": "astradesk_mtls",
                            "type": "certificate",
                            "value": "'"$(cat mtls-cert.pem)"'"
                        }'
                        rm -f mtls-cert.pem
                    '''
                }
            }
        }

        stage('Test Istio mTLS') {
            agent { docker { image 'bitnami/kubectl:latest' } }
            steps {
                unstash 'source'
                withCredentials([file(credentialsId: env.KUBE_CREDENTIALS_ID, variable: 'KUBECONFIG')]) {
                    sh '''
                        kubectl get peerauthentication -n astradesk-prod -o jsonpath='{.items[*].spec.mtls.mode}' | grep -q STRICT || exit 1
                        kubectl exec -n astradesk-prod -c istio-proxy $(kubectl get pod -l app=astradesk-api -n astradesk-prod -o jsonpath='{.items[0].metadata.name}') --kubeconfig=$KUBECONFIG -- curl -k https://api.astradesk.local/api/admin/v1/health > mtls-test.log 2>&1
                    '''
                    stash name: 'mtls-test-log', includes: 'mtls-test.log'
                }
            }
        }

        stage('Deploy to Kubernetes') {
            agent { docker { image 'alpine/helm:3.15.3' } }
            when { branch 'main' }
            steps {
                unstash 'source'
                withCredentials([file(credentialsId: env.KUBE_CREDENTIALS_ID, variable: 'KUBECONFIG')]) {
                    sh """
                        helm upgrade --install astradesk deploy/chart \
                            --set api.image.repository=${REGISTRY_URL}/astradesk-api \
                            --set api.image.tag=${IMAGE_TAG} \
                            --set ticketAdapter.image.repository=${REGISTRY_URL}/astradesk-ticket \
                            --set ticketAdapter.image.tag=${IMAGE_TAG} \
                            --set admin.image.repository=${REGISTRY_URL}/astradesk-admin \
                            --set admin.image.tag=${IMAGE_TAG} \
                            --set auditor.image.repository=${REGISTRY_URL}/astradesk-auditor \
                            --set auditor.image.tag=${IMAGE_TAG} \
                            --set api.autoscaling.enabled=true \
                            --set api.autoscaling.minReplicas=2 \
                            --set api.autoscaling.maxReplicas=10 \
                            --set api.autoscaling.targetCPUUtilizationPercentage=60 \
                            --set ticketAdapter.autoscaling.enabled=true \
                            --set ticketAdapter.autoscaling.minReplicas=2 \
                            --set ticketAdapter.autoscaling.maxReplicas=5 \
                            --set ticketAdapter.autoscaling.targetCPUUtilizationPercentage=60 \
                            --set admin.autoscaling.enabled=true \
                            --set admin.autoscaling.minReplicas=2 \
                            --set admin.autoscaling.maxReplicas=5 \
                            --set admin.autoscaling.targetCPUUtilizationPercentage=60 \
                            --set auditor.autoscaling.enabled=true \
                            --set auditor.autoscaling.minReplicas=2 \
                            --set auditor.autoscaling.maxReplicas=5 \
                            --set auditor.autoscaling.targetCPUUtilizationPercentage=60 \
                            --set database.postgres.host=$(terraform output -raw rds_postgres_endpoint) \
                            --set database.mysql.host=$(terraform output -raw rds_mysql_endpoint) \
                            --namespace astradesk-prod \
                            --create-namespace \
                            --wait --timeout 5m \
                            --kubeconfig=$KUBECONFIG
                    """
                }
            }
        }
    }

    post {
        always {
            archiveArtifacts artifacts: 'coverage.xml,**/jacocoTestReport.xml,services/admin-portal/coverage/**,infra/plan.out,ansible-test.log,puppet-test.log,salt-test.log,mtls-test.log', allowEmptyArchive: true
            junit '**/build/test-results/test/TEST-*.xml,pytest-report.xml'
        }
    }
}