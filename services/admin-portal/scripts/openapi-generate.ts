#!/usr/bin/env tsx
import { spawn } from "node:child_process";
import { existsSync, mkdirSync, statSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, join, resolve, isAbsolute } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const scriptDir = dirname(__filename);

function findRepoRoot(startDir: string): string {
  let current = startDir;
  while (true) {
    if (existsSync(join(current, ".git"))) {
      return current;
    }

    const parent = resolve(current, "..");
    if (parent === current) {
      throw new Error(`Unable to locate repository root from ${startDir}`);
    }

    current = parent;
  }
}

async function main() {
  const repoRoot = findRepoRoot(scriptDir);
  const adminPortalRoot = resolve(scriptDir, "..");

  const overridePath = process.env.ASTRA_OPENAPI_SPEC;
  const defaultSpecPath = resolve(repoRoot, "openapi/astradesk-admin.v1.yaml");

  const specPath = overridePath
    ? isAbsolute(overridePath)
      ? overridePath
      : resolve(repoRoot, overridePath)
    : defaultSpecPath;

  const searchedPaths = Array.from(
    new Set([
      specPath,
      defaultSpecPath,
      resolve(adminPortalRoot, "OpenAPI.yaml"),
    ]),
  );

  if (!existsSync(specPath)) {
    console.error("❌ OpenAPI specification not found.");
    console.error("Searched locations:");
    for (const candidate of searchedPaths) {
      console.error(` - ${candidate}`);
    }
    console.error(
      "Set ASTRA_OPENAPI_SPEC to override the spec location (absolute or relative to repo root).",
    );
    process.exit(1);
  }

  const stats = statSync(specPath);
  const outputPath = resolve(adminPortalRoot, "src/api/types.gen.ts");
  const outputDir = dirname(outputPath);

  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  console.log(`Spec: ${specPath}`);
  console.log(`Last modified: ${stats.mtime.toISOString()}`);
  console.log(`Output: ${outputPath}`);

  await runCommand(
    "npx",
    ["--yes", "openapi-typescript", specPath, "--output", outputPath],
    adminPortalRoot,
  ).catch((error) => {
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(2);
  });

  generateSpecOperations(specPath, adminPortalRoot);

  console.log("✅ OpenAPI types generated successfully.");
}

function runCommand(command: string, args: string[], cwd: string) {
  return new Promise<void>((resolvePromise, rejectPromise) => {
    const child = spawn(command, args, {
      cwd,
      stdio: "inherit",
      env: process.env,
    });

    child.on("error", (error) => rejectPromise(error));
    child.on("exit", (code) => {
      if (code === 0) {
        resolvePromise();
      } else {
        rejectPromise(new Error(`${command} exited with code ${code ?? "null"}`));
      }
    });
  });
}

type ExtractedOperation = {
  tag: string;
  method: string;
  path: string;
};

function generateSpecOperations(specPath: string, adminPortalRoot: string) {
  const raw = readFileSync(specPath, "utf-8");
  const operations = extractOperations(raw);
  if (operations.length === 0) {
    console.warn("⚠️  No operations extracted from OpenAPI spec. Skipping spec operations map generation.");
    return;
  }

  const sorted = operations.sort((a, b) => {
    if (a.tag !== b.tag) {
      return a.tag.localeCompare(b.tag);
    }
    if (a.path !== b.path) {
      return a.path.localeCompare(b.path);
    }
    return a.method.localeCompare(b.method);
  });

  const filePath = resolve(adminPortalRoot, "src/api/spec-operations.gen.ts");
  const lines = sorted
    .map(
      (op) =>
        `  { tag: ${JSON.stringify(op.tag)}, method: ${JSON.stringify(op.method)}, path: ${JSON.stringify(op.path)} },`,
    )
    .join("\n");

  const content = [
    '/* eslint-disable */',
    '/* Auto-generated by scripts/openapi-generate.ts. Do not edit manually. */',
    '',
    "export type SpecHttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';",
    '',
    'export type SpecOperation = {',
    '  tag: string;',
    '  method: SpecHttpMethod;',
    '  path: string;',
    '};',
    '',
    'export const specOperations: SpecOperation[] = [',
    lines,
    '];',
    '',
    'const OPERATION_SET = new Set(specOperations.map((operation) => operationKey(operation)));',
    '',
    'function operationKey(operation: SpecOperation): string {',
    '  return `\${operation.tag}|\${operation.method}|\${operation.path}`;',
    '}',
    '',
    'export function assertSpecOperation(tag: string, method: SpecHttpMethod, path: string): SpecOperation {',
    '  const key = `\${tag}|\${method}|\${path}`;',
    '  if (!OPERATION_SET.has(key)) {',
    '    throw new Error(`Operation not present in OpenAPI spec: \${method} \${path} (tag: \${tag})`);',
    '  }',
    '  return { tag, method, path };',
    '}',
    '',
  ].join('\n');

  writeFileSync(filePath, content);
}

function extractOperations(rawSpec: string): ExtractedOperation[] {
  const lines = rawSpec.split(/\r?\n/);
  const operations: ExtractedOperation[] = [];

  let inPathsSection = false;
  let currentPath: string | null = null;
  let pendingMethod: string | null = null;
  let recordedForMethod = false;

  const pathRegex = /^\s{2}\/.+:/;
  const methodRegex = /^\s{4}(get|post|put|delete|patch):\s*$/i;
  const tagsRegex = /^\s{6}tags:\s*\[([^\]]*)\]/i;

  const recordPendingOperation = (defaultTag = "default") => {
    if (currentPath && pendingMethod && !recordedForMethod) {
      operations.push({
        tag: defaultTag,
        method: pendingMethod,
        path: currentPath,
      });
      recordedForMethod = true;
    }
  };

  for (const line of lines) {
    if (!inPathsSection) {
      if (line.trim() === "paths:") {
        inPathsSection = true;
      }
      continue;
    }

    // Leave paths section when encountering another top-level key.
    if (/^[^\s]/.test(line) && !line.startsWith(" ")) {
      recordPendingOperation();
      break;
    }

    if (pathRegex.test(line)) {
      recordPendingOperation();
      const pathMatch = line.trim().slice(0, -1); // remove trailing ':'
      currentPath = pathMatch;
      pendingMethod = null;
      recordedForMethod = false;
      continue;
    }

    const methodMatch = line.match(methodRegex);
    if (methodMatch) {
      recordPendingOperation();
      pendingMethod = methodMatch[1].toUpperCase();
      recordedForMethod = false;
      continue;
    }

    const tagMatch = line.match(tagsRegex);
    if (tagMatch && pendingMethod && currentPath) {
      const tagList = tagMatch[1]
        .split(",")
        .map((tag) => tag.trim().replace(/^["']|["']$/g, ""))
        .filter(Boolean);
      const tag = tagList[0] ?? "default";
      operations.push({ tag, method: pendingMethod, path: currentPath });
      recordedForMethod = true;
      continue;
    }

    // Detect method end by reduced indentation (e.g., summary, responses, etc.)
    if (pendingMethod && /^\s{4}[a-zA-Z]/.test(line) && !/^\s{6}/.test(line)) {
      recordPendingOperation();
      pendingMethod = null;
      recordedForMethod = false;
    }
  }

  recordPendingOperation();

  return operations;
}

main().catch((error) => {
  console.error(error);
  process.exit(2);
});
