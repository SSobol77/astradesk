// AUTO-GENERATED BY openapi-typescript 6.7.0 â€“ DO NOT EDIT MANUALLY.
// The generated surface only includes the bits currently used by internal services.

export type Agent = {
  id: string;
  name?: string;
  version?: string;
  env?: "draft" | "dev" | "staging" | "prod" | string;
  status?: string;
  config?: Record<string, unknown>;
};

export type ProblemDetail = {
  type?: string;
  title?: string;
  status?: number;
  detail?: string;
  instance?: string;
};

export interface RequestConfig {
  baseUrl: string;
  token?: string;
  fetchFn?: typeof fetch;
  timeoutMs?: number;
}

export interface ListAgentsQuery {
  limit?: number;
  offset?: number;
}

export interface LogsExportQuery {
  format?: "json" | "ndjson" | "csv";
  agentId?: string;
  status?: string;
  from?: string;
  to?: string;
}

const DEFAULT_TIMEOUT = 30_000;

async function doRequest<T>(
  config: RequestConfig,
  method: string,
  path: string,
  init?: RequestInit
): Promise<T> {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), config.timeoutMs ?? DEFAULT_TIMEOUT);

  const fetchImpl = config.fetchFn ?? fetch;
  const headers: Record<string, string> = {};

  if (config.token) {
    headers.Authorization = `Bearer ${config.token}`;
  }

  try {
    const response = await fetchImpl(`${config.baseUrl}${path}`, {
      method,
      ...init,
      headers,
      signal: controller.signal,
    });

    if (!response.ok) {
      let problem: ProblemDetail | undefined;
      try {
        problem = (await response.json()) as ProblemDetail;
      } catch {
        problem = { detail: await response.text(), status: response.status };
      }
      throw new Error(`Admin API error ${response.status}: ${problem?.detail ?? problem?.title ?? "unknown"}`);
    }

    if (response.status === 204) {
      return undefined as T;
    }

    const contentType = response.headers.get("content-type") ?? "";
    if (contentType.includes("application/json")) {
      return (await response.json()) as T;
    }

    return (await response.arrayBuffer()) as T;
  } finally {
    clearTimeout(timeout);
  }
}

export async function listAgents(
  config: RequestConfig,
  query: ListAgentsQuery = {}
): Promise<Agent[]> {
  const params = new URLSearchParams();
  if (query.limit !== undefined) params.set("limit", String(query.limit));
  if (query.offset !== undefined) params.set("offset", String(query.offset));

  const suffix = params.toString() ? `/agents?${params}` : "/agents";
  return doRequest<Agent[]>(config, "GET", suffix);
}

export async function getAgent(config: RequestConfig, id: string): Promise<Agent> {
  return doRequest<Agent>(config, "GET", `/agents/${encodeURIComponent(id)}`);
}

export async function promoteAgent(config: RequestConfig, id: string): Promise<Agent> {
  return doRequest<Agent>(config, "POST", `/agents/${encodeURIComponent(id)}:promote`);
}

export async function exportLogs(
  config: RequestConfig,
  query: LogsExportQuery = {}
): Promise<ArrayBuffer> {
  const params = new URLSearchParams();
  if (query.format) params.set("format", query.format);
  if (query.agentId) params.set("agentId", query.agentId);
  if (query.status) params.set("status", query.status);
  if (query.from) params.set("from", query.from);
  if (query.to) params.set("to", query.to);

  const suffix = params.toString() ? `/logs/export?${params}` : "/logs/export";
  return doRequest<ArrayBuffer>(config, "GET", suffix);
}
